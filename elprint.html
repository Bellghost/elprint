<!doctype html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>canvas</title>
    <style>
      html,
      body {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      .ful-screen-container {
        display: flex;
        height: 100%;
        width: 100%;
        margin: 0;
        background-color: darkgrey;
      }

      #canvas {
        flex: 1;
      }

      #toolbar {
        width: 15%;

        #color-selector {
          width: 100%;
          height: 40%;
        }

        #print-tool-selector {
          width: 100%;
          height: 60%;
          /* border: 20px solid conic-gradient(from 0deg, rgb(255,0,0), rgb(255,255,0), rgb(0,255,0), rgb(0,255,255), rgb(0,0,255), rgb(255,0,255), rgb(255,0,0)); */
        }
      }

      .color-ring {
        /* width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(from 0deg, rgb(255,0,0), rgb(255,255,0), rgb(0,255,0), rgb(0,255,255), rgb(0,0,255), rgb(255,0,255), rgb(255,0,0));         */

        width: 80%; /* 圆环整体直径 */
        height: 80%; /* 宽高相等才能形成正圆 */
        border-radius: 50%; /* 圆角设为50%变成圆形 */
        border: 20px solid
          conic-gradient(
            from 0deg,
            rgb(255, 0, 0),
            rgb(255, 255, 0),
            rgb(0, 255, 0),
            rgb(0, 255, 255),
            rgb(0, 0, 255),
            rgb(255, 0, 255),
            rgb(255, 0, 0)
          ); /* 边框宽度=圆环宽度，颜色=圆环颜色 */
        background: transparent; /* 中间区域透明，形成中空 */
        /* 可选：添加阴影让圆环更立体 */
        /* box-shadow: 0 0 10px rgba(64, 158, 255, 0.5); */
      }
    </style>
  </head>

  <body>
    <div class="ful-screen-container">
      <canvas id="canvas"> 你的浏览器不支持 canvas，请升级你的浏览器。 </canvas>

      <div id="toolbar">
        <canvas id="color-selector">
          你的浏览器不支持 canvas，请升级你的浏览器。
        </canvas>
        <!-- <div id="color-selector">
          <div class="color-ring"></div>
        </div> -->

        <canvas id="print-tool-selector">
          你的浏览器不支持 canvas，请升级你的浏览器。
        </canvas>
      </div>
    </div>

    <script type="text/javascript">
      const canvas = document.getElementById("canvas");
      const colorSelector = document.getElementById("color-selector");
      const printToolSelector = document.getElementById("print-tool-selector");

      function initCanvasSize() {
        canvas.width = window.innerWidth * 0.85;
        canvas.height = window.innerHeight;
      }

      function initCanvasBackground() {
        if (!canvas.getContext) return;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "white";

        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      let path = [];
      let isPrinting = false;
      let startPath = { x: 0, y: 0 };

      canvas.addEventListener("mousemove", function (event) {
        if (!isPrinting) return;
        const x = event.clientX;
        const y = event.clientY;
        path.push({ x, y });
      });

      canvas.addEventListener("mousedown", function (event) {
        isPrinting = true;
        startPath = { x: event.clientX, y: event.clientY };
        path = [];
      });

      canvas.addEventListener("mouseup", function (event) {
        isPrinting = false;
      });

      canvas.addEventListener("touchstart", function (event) {
        console.log("touchstart");
        console.log(event);
        console.log(event.touches[0].clientX, event.touches[0].clientY);
        isPrinting = true;
        startPath = {
          x: event.touches[0].clientX,
          y: event.touches[0].clientY,
        };
        path = [];
      });

      canvas.addEventListener("touchmove", function (event) {
        console.log("touchmove");
        console.log(event);
        console.log(event.touches[0].force);
        if (!isPrinting) return;
        const x = event.touches[0].clientX;
        const y = event.touches[0].clientY;
        path.push({ x, y });
      });

      canvas.addEventListener("touchend", function (event) {
        isPrinting = false;
      });

      function printPath() {
        const ctx = canvas.getContext("2d");
        ctx.beginPath();
        ctx.moveTo(startPath.x, startPath.y);
        if (path.length > 0) {
          ctx.moveTo(startPath.x, startPath.y);
          for (let i = 0; i < path.length; i++) {
            ctx.lineTo(path[i].x, path[i].y);
          }
        }
        ctx.stroke();
      }

      function initColorSelectorSize() {
        // 获取父容器的实际尺寸
        const parentWidth = colorSelector.parentElement.clientWidth;
        const parentHeight = colorSelector.parentElement.clientHeight;

        // 设置 canvas 的实际分辨率
        colorSelector.width = parentWidth;
        colorSelector.height = parentHeight * 0.4;
      }

      function drawAngularGradientRing(
        ctx,
        centerX,
        centerY,
        innerRadius,
        outerRadius,
        segments = 128 * 3,
      ) {
        const angleStep = (Math.PI * 2) / segments; // 每个小扇形的角度
        let r = 255;
        let g = 0;
        let b = 0;
        for (let i = 0; i < segments; i++) {
          const startAngle = i * angleStep;
          const endAngle = (i + 1) * angleStep;

          if (i < 64) {
            g += 4; // 渐变成rgb(255, 255, 0)
          } else if (i < 128) {
            r -= 4; // 渐变成rgb(0, 255, 0)
          } else if (i < 192) {
            b += 4; // 渐变成rgb(0, 255, 255)
          } else if (i < 256) {
            g -= 4; // 渐变成rgb(0, 0, 255)
          } else if (i < 320) {
            r += 4; // 渐变成rgb(255, 0, 255)
          } else if (i < 384) {
            b -= 2; // 渐变成rgb(255, 0, 0)
          }

          const color = `rgb(${r}, ${g}, ${b})`;
          // 绘制外圆弧
          ctx.beginPath();
          ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle);
          ctx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true); // 内圆弧（逆时针）
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
        }
      }

      function initColorSelectorBackground() {
        if (!colorSelector.getContext) return;
        const ctx = colorSelector.getContext("2d");

        // 填充灰色背景
        ctx.fillStyle = "gray";
        ctx.fillRect(0, 0, colorSelector.width, colorSelector.height);

        let r =
          (colorSelector.width < colorSelector.height
            ? colorSelector.width / 2
            : colorSelector.height / 2) - 8;

        drawAngularGradientRing(ctx, r + 8, r + 8, r - 20, r); // 圆心(200,200)，内半径50，外半径100
      }

      function initPrintToolSize() {
        // 获取父容器的实际尺寸
        const parentWidth = printToolSelector.parentElement.clientWidth;
        const parentHeight = printToolSelector.parentElement.clientHeight;

        // 设置 canvas 的实际分辨率
        printToolSelector.width = parentWidth;
        printToolSelector.height = parentHeight * 0.6;
      }

      function initPrintToolBackground() {
        if (!printToolSelector.getContext) return;
        const ctx = printToolSelector.getContext("2d");

        // 填充灰色背景
        ctx.fillStyle = "gray";
        ctx.fillRect(0, 0, printToolSelector.width, printToolSelector.height);

        // 设置三角形的颜色
        ctx.fillStyle = "green"; // 三角形颜色为红色

        // 绘制第一个三角形
        ctx.beginPath();
        ctx.moveTo(50, 50); // 起始点
        ctx.lineTo(50, 100); // 第二个点
        ctx.lineTo(100, 100); // 第三个点
        ctx.closePath(); // 闭合路径
        ctx.fill(); // 填充三角形
      }

      initCanvasSize();
      initCanvasBackground();
      initColorSelectorSize();
      initColorSelectorBackground();
      initPrintToolSize();
      initPrintToolBackground();

      setInterval(printPath, 5);
    </script>
  </body>
</html>
